# The Workflow By GruntFish & DS.

name: Sync-repos

on:
  workflow_dispatch:
    inputs:
      source_repo:
        description: '同步的仓库地址（格式:所有者/仓库名）'
        required: true
        type: string
      source_branch:
        description: '同步的仓库分支（留空使用其默认分支）'
        required: false
        type: string
      source_path:
        description: '同步特定路径（文件夹或文件，可为空）'
        required: false
        type: string
      source_type:
        description: '同步类型'
        required: true
        type: choice
        default: 'auto'
        options:
        - auto
        - file
        - directory
      target_branch:
        description: '保存到当前仓库的目标分支（为空主分支）'
        required: true
        type: string
        default: 'Packages'
      target_folder:
        description: '保存的文件夹路径（留空用被同步仓库名）'
        required: false
        type: string
      confirm_replace:
        description: '确认替换本仓库内存在的文件或目录！'
        required: true
        type: boolean
        default: false
      clean_default_files:
        description: '清理新建分支的默认文件及工作流等！'
        required: true
        type: boolean
        default: true


jobs:
  sync-to-current-repo:
    runs-on: ubuntu-latest
    
    steps:
    - name: 检出默认分支
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        
    - name: 设置Git配置
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

    - name: 同步并保存仓库
      env:
        SOURCE_REPO: ${{ github.event.inputs.source_repo }}
        SOURCE_BRANCH: ${{ github.event.inputs.source_branch }}
        SOURCE_PATH: ${{ github.event.inputs.source_path }}
        SOURCE_TYPE: ${{ github.event.inputs.source_type }}
        TARGET_FOLDER: ${{ github.event.inputs.target_folder }}
        CONFIRM_REPLACE: ${{ github.event.inputs.confirm_replace }}
      run: |
        repo_name=$(basename "$SOURCE_REPO")
        
        if [ -n "$TARGET_FOLDER" ]; then
          base_target_path="$TARGET_FOLDER"
        else
          base_target_path=""
        fi
        
        if [ -n "$SOURCE_PATH" ]; then
          folder_name=$(basename "$SOURCE_PATH")
          if [ -n "$base_target_path" ]; then
            final_target_path="$base_target_path/$folder_name"
          else
            final_target_path="$folder_name"
          fi
        else
          final_target_path="$base_target_path"
        fi
        
        echo "同步仓库: $SOURCE_REPO"
        echo "分支: ${SOURCE_BRANCH:-默认分支}"
        echo "源路径: ${SOURCE_PATH:-整个仓库}"
        echo "同步类型: $SOURCE_TYPE"
        echo "保存到: ${final_target_path:-根目录}"
        
        temp_dir=$(mktemp -d)
        
        if [ -n "$SOURCE_BRANCH" ]; then
          git clone --depth 1 --branch "$SOURCE_BRANCH" "https://github.com/$SOURCE_REPO.git" "$temp_dir"
        else
          git clone --depth 1 "https://github.com/$SOURCE_REPO.git" "$temp_dir"
        fi
        
        if [ -n "$final_target_path" ]; then
          mkdir -p "$(dirname "$final_target_path")"
        fi
        
        if [ -n "$SOURCE_PATH" ]; then
          source_item="$temp_dir/$SOURCE_PATH"
          if [ ! -e "$source_item" ]; then
            echo "错误: 路径 '$SOURCE_PATH' 在仓库中不存在"
            exit 1
          fi
          
          case "$SOURCE_TYPE" in
            "file")
              if [ ! -f "$source_item" ]; then
                echo "错误: 路径 '$SOURCE_PATH' 不是文件"
                exit 1
              fi
              ;;
            "directory")
              if [ ! -d "$source_item" ]; then
                echo "错误: 路径 '$SOURCE_PATH' 不是目录"
                exit 1
              fi
              ;;
          esac
        fi
        
        if [ -n "$final_target_path" ] && [ -e "$final_target_path" ]; then
          if [ "$CONFIRM_REPLACE" = "true" ]; then
            echo "正在删除已存在的路径: $final_target_path"
            rm -rf "$final_target_path"
          else
            echo "错误: 路径 '$final_target_path' 已存在，但未确认替换"
            exit 1
          fi
        fi
        
        if [ -n "$SOURCE_PATH" ]; then
          source_item="$temp_dir/$SOURCE_PATH"
          if [ -n "$final_target_path" ]; then
            mkdir -p "$final_target_path"
          fi
          
          if [ -d "$source_item" ]; then
            if command -v rsync >/dev/null; then
              rsync -av "$source_item"/ "${final_target_path:-.}"/
            else
              cp -rp "$source_item"/* "${final_target_path:-.}"/
            fi
          else
            cp -p "$source_item" "${final_target_path:-.}"/
          fi
        else
          if [ -n "$final_target_path" ]; then
            mkdir -p "$final_target_path"
            if command -v rsync >/dev/null; then
              rsync -av "$temp_dir"/ "$final_target_path"/
            else
              cp -rp "$temp_dir"/* "$final_target_path"/
            fi
          else
            if command -v rsync >/dev/null; then
              rsync -av "$temp_dir"/ ./
            else
              cp -rp "$temp_dir"/* ./
            fi
          fi
        fi
        
        if [ -d "${final_target_path:-.}" ]; then
          echo "修复可执行文件权限..."
          
          find "${final_target_path:-.}" -type f \( -name "*.sh" -o -name "*.bash" -o -name "*.py" -o -name "*.pl" -o -name "*.rb" -o -name "*.php" -o -name "*.lua" \) -exec chmod +x {} \; 2>/dev/null || true
          
          find "${final_target_path:-.}" -type d -name "bin" | while read bin_dir; do
            find "$bin_dir" -type f -exec chmod +x {} \; 2>/dev/null || true
          done
          
          find "${final_target_path:-.}" -type d \( -path "*/usr/bin" -o -path "*/usr/local/bin" -o -path "*/usr/sbin" -o -path "*/sbin" -o -path "*/opt/bin" \) | while read bin_dir; do
            find "$bin_dir" -type f -exec chmod +x {} \; 2>/dev/null || true
          done
          
          find "${final_target_path:-.}" -type f ! -name "*.*" -exec sh -c '
            file="$1"
            if [ -s "$file" ] && head -n 1 "$file" | grep -q "^#!"; then
              echo "修复脚本权限: $file"
              chmod +x "$file"
            fi
          ' _ {} \; 2>/dev/null || true
          
          if [ -n "$final_target_path" ]; then
            rm -rf "$final_target_path/.git" 2>/dev/null || true
          fi
        fi
        
        rm -rf "$temp_dir"
        
        echo "完成: 保存到 ${final_target_path:-根目录}"

    - name: 清理默认文件
      if: ${{ github.event.inputs.clean_default_files == 'true' }}
      run: |
        CURRENT_BRANCH="${{ github.event.inputs.target_branch }}"
        DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"
        
        if [ "$CURRENT_BRANCH" = "$DEFAULT_BRANCH" ]; then
          echo "警告：当前在默认分支 $DEFAULT_BRANCH，跳过清理以避免误删工作流文件！"
          exit 0
        fi
        
        echo "警告：正在清理所有默认文件，包括工作流！"
        
        if [ -d ".github/workflows" ]; then
          rm -rf .github/workflows
          echo "已删除工作流文件"
        fi
        
        [ -f "README.md" ] && rm -f README.md && echo "已删除README.md"
        [ -f ".gitignore" ] && rm -f .gitignore && echo "已删除.gitignore"
        [ -f "LICENSE" ] && rm -f LICENSE && echo "已删除LICENSE"
        
        if [ -d ".github" ] && [ -z "$(ls -A .github)" ]; then
          rm -rf .github
          echo "已删除空.github目录"
        fi
        
        echo "清理完成！注意：此操作会删除工作流，下次需要重新上传工作流文件才能使用"

    - name: 创建并切换到目标分支
      run: |
        TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
        echo "目标分支: $TARGET_BRANCH"
        
        # 检查分支是否存在
        if git ls-remote --heads origin "$TARGET_BRANCH" | grep -q "$TARGET_BRANCH"; then
          echo "分支已存在，切换到: $TARGET_BRANCH"
          git checkout "$TARGET_BRANCH"
        else
          echo "创建新分支: $TARGET_BRANCH"
          git checkout -b "$TARGET_BRANCH"
        fi
        
        # 验证分支切换
        CURRENT_BRANCH=$(git branch --show-current)
        echo "当前分支: $CURRENT_BRANCH"
        
        if [ "$CURRENT_BRANCH" != "$TARGET_BRANCH" ]; then
          echo "❌ 分支切换失败！强制修复..."
          git checkout -B "$TARGET_BRANCH"
          echo "修复后分支: $(git branch --show-current)"
        fi

    - name: 提交更改
      run: |
        git remote set-url origin https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
        git add .
        git commit -m "添加仓库: ${{ github.event.inputs.source_repo }}${{ github.event.inputs.source_path && format(' (路径: {0})', github.event.inputs.source_path) || '' }}"
        git push
